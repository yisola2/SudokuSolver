\chapter{Testing and Validation}

\section{Testing Strategy}
The testing approach for the Sudoku solver follows several levels of validation:

\subsection{Unit Testing}
Individual components are tested in isolation to verify their correct behavior:

\begin{algorithmic}[1]
\Function{testCandidateManager}{}
    \State board ← createEmptyBoard()
    \State manager ← new CandidateManager(board)
    
    \State // Test initial candidates
    \For{each cell in board}
        \State candidates ← manager.getCandidates(cell)
        \State Assert candidates = {1,2,3,4,5,6,7,8,9}
    \EndFor
    
    \State // Test candidate update
    \State board.setValue(0, 5)
    \State affected ← getAffectedCells(0)
    \For{each cell in affected}
        \State Assert not manager.getCandidates(cell).contains(5)
    \EndFor
\EndFunction
\end{algorithmic}

\subsection{Rule Testing}
Each deduction rule is tested with specific puzzle configurations:

\begin{itemize}
    \item \textbf{DR1 Test Cases}:
    \begin{enumerate}
        \item Empty grid with one cell having single candidate
        \item Multiple cells with single candidates
        \item No single candidates available
    \end{enumerate}
    
    \item \textbf{DR2 Test Cases}:
    \begin{enumerate}
        \item Hidden single in row
        \item Hidden single in column
        \item Hidden single in box
        \item Multiple hidden singles
    \end{enumerate}
    
    \item \textbf{DR3 Test Cases}:
    \begin{enumerate}
        \item Locked candidates in row-box interaction
        \item Locked candidates in column-box interaction
        \item Multiple locked candidate patterns
    \end{enumerate}
\end{itemize}

\section{Validation System}

\subsection{Move Validation}
Each move is validated before being applied to the board:

\begin{algorithmic}[1]
\Function{validateMove}{board, index, value}
    \If{value < 1 or value > 9}
        \State \Return false
    \EndIf
    
    \State row ← index / 9
    \State col ← index mod 9
    \State box ← getBoxNumber(row, col)
    
    \State \Return not (
        \State \quad existsInRow(board, row, value) or
        \State \quad existsInColumn(board, col, value) or
        \State \quad existsInBox(board, box, value)
    \State )
\EndFunction
\end{algorithmic}

\subsection{Puzzle State Validation}
The overall puzzle state is validated to ensure consistency:

\begin{algorithmic}[1]
\Function{validatePuzzleState}{board}
    \For{each unit in [rows, columns, boxes]}
        \If{not isUnitValid(unit)}
            \State \Return false
        \EndIf
    \EndFor
    \State \Return true
\EndFunction

\Function{isUnitValid}{unit}
    \State seen ← array[10] of boolean
    \For{each cell in unit}
        \State value ← cell.getValue()
        \If{value ≠ empty}
            \If{seen[value]}
                \State \Return false
            \EndIf
            \State seen[value] ← true
        \EndIf
    \EndFor
    \State \Return true
\EndFunction
\end{algorithmic}

\section{Test Cases}
A comprehensive set of test puzzles was used to verify solver functionality:

\begin{table}[H]
\centering
\begin{tabular}{|l|l|p{8cm}|}
\hline
\textbf{Difficulty} & \textbf{Rules Required} & \textbf{Description} \\
\hline
Easy & DR1 only & Puzzles solvable using only single candidate technique \\
\hline
Medium & DR1 + DR2 & Requires hidden singles to solve \\
\hline
Hard & DR1 + DR2 + DR3 & Requires locked candidates technique \\
\hline
Very Hard & All + User Input & Requires user intervention after rules application \\
\hline
\end{tabular}
\caption{Test Puzzle Categories}
\label{table:test-cases}
\end{table}

\section{Error Handling}

\subsection{Input Validation}
File input errors are handled systematically:

\begin{algorithmic}[1]
\Function{validateInputFile}{filename}
    \Try
        \State lines ← readAllLines(filename)
        \If{lines.size ≠ 9}
            \State throw "Invalid number of lines"
        \EndIf
        \For{each line in lines}
            \State values ← split(line, ",")
            \If{values.size ≠ 9}
                \State throw "Invalid line format"
            \EndIf
            \For{each value in values}
                \If{not isValidValue(value)}
                    \State throw "Invalid value format"
                \EndIf
            \EndFor
        \EndFor
    \Catch{Exception e}
        \State logError(e)
        \State displayUserFriendlyMessage()
        \State \Return false
    \EndTry
    \State \Return true
\EndFunction
\end{algorithmic}

\subsection{Runtime Error Handling}
The solver implements graceful error handling during execution:

\begin{itemize}
    \item \textbf{Invalid User Input}: Prompts for correction
    \item \textbf{Inconsistent State}: Requests puzzle restart
    \item \textbf{Unsolvable Puzzles}: Provides appropriate feedback
    \item \textbf{Resource Issues}: Handles memory and file system errors
\end{itemize}

\section{Performance Testing}
Performance metrics were collected for different puzzle difficulties:

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Puzzle Type} & \textbf{Avg. Solve Time} & \textbf{Rule Applications} & \textbf{Memory Usage} \\
\hline
Easy & < 100ms & 10-20 & Minimal \\
\hline
Medium & 100-500ms & 20-50 & Low \\
\hline
Hard & 500ms-1s & 50-100 & Moderate \\
\hline
Very Hard & > 1s & 100+ & Moderate \\
\hline
\end{tabular}
\caption{Performance Metrics}
\label{table:performance}
\end{table}
