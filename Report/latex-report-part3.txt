\chapter{Implementation}

\section{Core Components}

\subsection{Board Representation}
The Sudoku board is implemented using a linear array representation for efficient access and manipulation. Each cell maintains its value and candidate list.

\begin{algorithmic}[1]
\State \textbf{class} SudokuBoard
    \State cells[81]: array of Cell
    \State candidateManager: CandidateManager
    
    \Function{getValue}{index}
        \If{index < 0 or index ≥ 81}
            \State throw InvalidIndexError
        \EndIf
        \State \Return cells[index].value
    \EndFunction
    
    \Function{setValue}{index, value}
        \If{value is valid}
            \State cells[index].value ← value
            \State updateCandidates(index, value)
        \EndIf
    \EndFunction
\end{algorithmic}

\subsection{Candidate Management}
The CandidateManager maintains possible values for each cell and updates them when values are set.

\begin{algorithmic}[1]
\Function{updateCandidates}{index, value}
    \State affectedIndices ← getAffectedIndices(index)
    \For{each idx in affectedIndices}
        \If{board[idx] is empty}
            \State removeCandidateFromCell(idx, value)
        \EndIf
    \EndFor
\EndFunction

\Function{getAffectedIndices}{index}
    \State indices ← empty set
    \State row ← index / 9
    \State col ← index mod 9
    
    \State Add all cells in same row
    \State Add all cells in same column
    \State Add all cells in same 3x3 box
    
    \State \Return indices
\EndFunction
\end{algorithmic}

\section{Deduction Rules}

\subsection{DR1: Single Candidate}
DR1 finds cells that have only one possible value in their candidate list.

\begin{algorithmic}[1]
\Function{DR1\_execute}{board}
    \State progress ← false
    \For{each cell in board}
        \If{cell is empty}
            \State candidates ← getCandidates(cell)
            \If{candidates.size = 1}
                \State value ← candidates.first()
                \State board.setValue(cell.index, value)
                \State progress ← true
            \EndIf
        \EndIf
    \EndFor
    \State \Return progress
\EndFunction
\end{algorithmic}

\subsection{DR2: Hidden Singles}
DR2 finds values that can only appear in one position within a unit (row, column, or box).

\begin{algorithmic}[1]
\Function{DR2\_execute}{board}
    \State progress ← false
    \For{each unit in [rows, columns, boxes]}
        \For{each value in 1..9}
            \State positions ← findPossiblePositions(unit, value)
            \If{positions.size = 1}
                \State cell ← positions.first()
                \State board.setValue(cell, value)
                \State progress ← true
            \EndIf
        \EndFor
    \EndFor
    \State \Return progress
\EndFunction
\end{algorithmic}

\subsection{DR3: Locked Candidates}
DR3 eliminates candidates based on box-line interactions.

\begin{algorithmic}[1]
\Function{DR3\_execute}{board}
    \State progress ← false
    \For{each box in grid}
        \For{each value in 1..9}
            \State rowPositions ← findPossibleRowsInBox(box, value)
            \State colPositions ← findPossibleColsInBox(box, value)
            
            \If{rowPositions.size = 1}
                \State eliminateFromRestOfRow(rowPositions.first(), box, value)
                \State progress ← true
            \EndIf
            
            \If{colPositions.size = 1}
                \State eliminateFromRestOfColumn(colPositions.first(), box, value)
                \State progress ← true
            \EndIf
        \EndFor
    \EndFor
    \State \Return progress
\EndFunction
\end{algorithmic}

\section{Solving Process}
The main solving algorithm combines the deduction rules with user interaction when needed.

\begin{algorithmic}[1]
\Function{solve}{board}
    \State rules ← [DR1, DR2, DR3]
    \State progress ← true
    \While{not board.isFull() and progress}
        \State progress ← false
        \For{each rule in rules}
            \If{rule.apply(board)}
                \State progress ← true
                \State break
            \EndIf
        \EndFor
        \If{not progress}
            \If{getUserInput(board)}
                \State progress ← true
            \Else
                \State \Return false \Comment{Invalid state}
            \EndIf
        \EndIf
    \EndWhile
    \State \Return board.isFull()
\EndFunction
\end{algorithmic}

\section{File Handling}
The file handling component manages puzzle input and output in the specified format.

\begin{algorithmic}[1]
\Function{loadPuzzle}{filename}
    \State board ← new SudokuBoard
    \State lines ← readLines(filename)
    \If{lines.size ≠ 9}
        \State throw FormatError
    \EndIf
    \For{row ← 0 to 8}
        \State values ← split(lines[row], ",")
        \If{values.size ≠ 9}
            \State throw FormatError
        \EndIf
        \For{col ← 0 to 8}
            \State value ← parseInt(values[col])
            \If{value ≠ 0}
                \State board.setValue(row * 9 + col, value)
            \EndIf
        \EndFor
    \EndFor
    \State \Return board
\EndFunction
\end{algorithmic}
